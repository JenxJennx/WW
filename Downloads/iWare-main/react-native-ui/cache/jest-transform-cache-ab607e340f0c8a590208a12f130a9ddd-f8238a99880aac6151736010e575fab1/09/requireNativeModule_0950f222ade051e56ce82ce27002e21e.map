{"version":3,"mappings":";;;;;;;AAAA;;AAoBM,SAAUA,mBAAV,CAAgDC,UAAhD,EAAkE;EAAA;;EACtE,IAAMC,YAAY,mDAChBC,MAAM,CAACC,WADS,qBAChB,oBAAqBH,UAArB,CADgB,oCACoBI,4BAAmBJ,UAAnB,CADtC;;EAGA,IAAI,CAACC,YAAL,EAAmB;IACjB,MAAM,IAAII,KAAJ,iCAAwCL,UAAxC,OAAN;EACD;;EACD,OAAOC,YAAP;AACD","names":["requireNativeModule","moduleName","nativeModule","global","ExpoModules","NativeModulesProxy","Error"],"sourceRoot":"","sources":["../src/requireNativeModule.ts"],"sourcesContent":["import NativeModulesProxy from './NativeModulesProxy';\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var ExpoModules:\n    | undefined\n    | {\n        [key: string]: any;\n      };\n}\n\n/**\n * Imports the native module registered with given name. In the first place it tries to load\n * the module installed through the JSI host object and then falls back to the bridge proxy module.\n * Notice that the modules loaded from the proxy may not support some features like synchronous functions.\n *\n * @param moduleName Name of the requested native module.\n * @returns Object representing the native module.\n * @throws Error when there is no native module with given name.\n */\nexport function requireNativeModule<ModuleType = any>(moduleName: string): ModuleType {\n  const nativeModule: ModuleType =\n    global.ExpoModules?.[moduleName] ?? NativeModulesProxy[moduleName];\n\n  if (!nativeModule) {\n    throw new Error(`Cannot find native module '${moduleName}'`);\n  }\n  return nativeModule;\n}\n"]}